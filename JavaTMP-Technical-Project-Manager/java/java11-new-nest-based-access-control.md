### 📌 **Java 11: New Nest-Based Access Control**

The **Nest-Based Access Control** introduced in **Java 11** is a new feature that improves **encapsulation** and **access control** between **nested classes**. It allows inner classes, outer classes, and nested static classes in the same **"nest"** to access each other's private members directly without requiring synthetic bridge methods.

This change simplifies how **inner classes** access the **private members** of their **outer classes** and vice versa. It also makes the Java language more **in line with modern encapsulation principles**.

---

## 🧩 **What is a "Nest"?**

A **nest** is a new concept introduced in Java 11, representing a **group of classes that are logically part of the same unit**. Typically, this means an **outer class** and its **nested classes** (including static and non-static inner classes).

Classes in the same **nest** can now:

- Access **private fields**.
- Access **private methods**.
- Access **private constructors**.

Without needing **synthetic bridge methods**, which were previously generated by the compiler to achieve this.

---

## 📜 **New Class File Attributes**

Java 11 introduces **two new attributes** in the class file to support this feature:

1. **`NestHost`** – Specifies the primary class (the outer class) that represents the nest.
2. **`NestMembers`** – Lists the classes that are part of the same nest.

---

### 🛠 **Example of Nest-Based Access Control**

#### **Before Java 11:**
In Java versions **before Java 11**, if an inner class tried to access a private member of its outer class, the **compiler would generate synthetic bridge methods** to facilitate this access.

```java
public class OuterClass {
    private String message = "Hello from OuterClass!";

    class InnerClass {
        void printMessage() {
            System.out.println(message);
        }
    }
}
```

In Java 8 or earlier, the **`InnerClass`** would need a **synthetic method** to access the **private `message` field** in **`OuterClass`**.

---

#### **Java 11 (Nest-Based Access Control):**
In Java 11, the **synthetic method is no longer required**. The **`InnerClass`** can directly access the **private members** of the **`OuterClass`** because they belong to the same **nest**.

```java
public class OuterClass {
    private String message = "Hello from OuterClass!";

    class InnerClass {
        void printMessage() {
            System.out.println(message);
        }
    }
}
```

---

### 🔎 **Verifying Nest Information in Class Files**

You can use the **`javap` tool** to inspect the class file and see the **`NestHost`** and **`NestMembers`** attributes.

```bash
javac OuterClass.java
javap -v OuterClass
```

#### **Output:**

```text
NestHost: OuterClass
NestMembers:
  OuterClass$InnerClass
```

---

### ✅ **Benefits of Nest-Based Access Control**

| **Benefit**                     | **Description**                                              |
|----------------------------------|--------------------------------------------------------------|
| **Improved Encapsulation**       | Inner and outer classes can share private members directly.  |
| **Simplified Bytecode**          | Reduces the need for synthetic bridge methods.               |
| **Performance Improvement**      | Less overhead in accessing private members.                  |
| **Cleaner Class Files**          | Simplifies the structure of the generated class files.       |

---

### 🚀 **Practical Example:**

Here’s a more detailed example of using **nest-based access control**:

```java
public class OuterClass {
    private int number = 42;

    // Nested class
    class InnerClass {
        private void displayNumber() {
            System.out.println("Number from OuterClass: " + number);
        }
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.displayNumber();
    }
}
```

### ✅ **Output:**

```
Number from OuterClass: 42
```

---

### ⚙️ **How It Works Internally:**

In Java 11, the JVM treats both **`OuterClass`** and **`InnerClass`** as part of the same **nest**. Therefore, **`InnerClass`** can directly access **`number`**, even though it's a **private field** in **`OuterClass`**, without requiring a synthetic method.

---

### 🔄 **Backward Compatibility:**
The **Nest-Based Access Control** is **backward compatible**. Existing class files compiled with older Java versions will continue to work, even if they rely on synthetic methods for inner class access.

---

### 🧪 **When to Use Nest-Based Access Control?**

- When you have **nested inner classes**.
- When you need to **access private fields or methods** across these nested classes.
- To **reduce synthetic methods** and make your **class files cleaner and more efficient**.

---

### 💡 **Key Points to Remember:**

| **Feature**                  | **Description**                                              |
|------------------------------|--------------------------------------------------------------|
| **NestHost**                  | Identifies the main class of a nest.                        |
| **NestMembers**               | Lists the classes that belong to the nest.                  |
| **No Synthetic Methods**      | Eliminates the need for synthetic bridge methods.            |

---
